{
  "name": "My workflow 26",
  "nodes": [
    {
      "parameters": {
        "updates": [
          "message",
          "edited_message"
        ],
        "additionalFields": {
          "download": false
        }
      },
      "id": "69c63fb0-ffad-4f8e-9170-9d5caa01a89f",
      "name": "Telegram Trigger",
      "type": "n8n-nodes-base.telegramTrigger",
      "typeVersion": 1,
      "position": [
        -2140,
        900
      ],
      "webhookId": "telegram-bot-horizon",
      "credentials": {
        "telegramApi": {
          "id": "AxkZ01LKYRFoDdI5",
          "name": "research bot"
        }
      }
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "horizon-document-upload",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "2188bb9e-0bf1-4d1d-bc2c-ccc397fdf977",
      "name": "External Document Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -2140,
        700
      ],
      "webhookId": "external-doc-upload"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Route Detection with Bot Message Filtering\nconst update = $json;\nlet routeType = 'unknown';\nlet data = {};\n\n// IMPORTANT: Skip bot messages to prevent loops\nif (update.message && update.message.from && update.message.from.is_bot) {\n  console.log('Skipping bot message to prevent loop');\n  return {\n    json: {\n      routeType: 'skip',\n      reason: 'Bot message ignored to prevent loop'\n    }\n  };\n}\n\n// Check if it's from external webhook\nif (update.headers && update.headers['x-source'] === 'external-upload') {\n  // Handle external document upload\n  if (update.body && update.body.document) {\n    const doc = update.body.document;\n    routeType = 'document';\n    data = {\n      routeType: 'document',\n      fileId: doc.fileId || null,\n      fileName: doc.fileName || doc.name || 'unknown',\n      mimeType: doc.mimeType || 'application/octet-stream',\n      fileSize: doc.fileSize || null,\n      fileUrl: doc.url || null,\n      fileContent: doc.content || null,\n      chatId: update.body.chatId || 'external',\n      userId: update.body.userId || 'external-user',\n      username: update.body.username || 'External User',\n      messageId: update.body.messageId || null,\n      source: 'external'\n    };\n  }\n}\n// Handle Telegram messages\nelse if (update.message) {\n  // Check if it's a command\n  if (update.message.text?.startsWith('/')) {\n    const command = update.message.text.split(' ')[0].toLowerCase();\n    \n    if (command === '/export') {\n      routeType = 'export';\n      data = {\n        routeType: 'export',\n        command: 'export',\n        chatId: update.message.chat.id,\n        userId: update.message.from.id,\n        username: update.message.from.username || update.message.from.first_name,\n        messageId: update.message.message_id,\n        filters: update.message.text.substring(7).trim()\n      };\n    } else if (command === '/stats') {\n      routeType = 'stats';\n      data = {\n        routeType: 'stats',\n        command: 'stats',\n        chatId: update.message.chat.id,\n        userId: update.message.from.id,\n        username: update.message.from.username || update.message.from.first_name,\n        messageId: update.message.message_id\n      };\n    }\n  }\n  // Check if it's a document upload\n  else if (update.message.document) {\n    const doc = update.message.document;\n    routeType = 'document';\n    data = {\n      routeType: 'document',\n      fileId: doc.file_id,\n      fileName: doc.file_name || 'unknown',\n      mimeType: doc.mime_type || 'application/octet-stream',\n      fileSize: doc.file_size,\n      chatId: update.message.chat.id,\n      userId: update.message.from.id,\n      username: update.message.from.username || update.message.from.first_name,\n      messageId: update.message.message_id,\n      source: 'telegram'\n    };\n  } \n  // Check if it's a text message with URL\n  else if (update.message.text) {\n    const text = update.message.text;\n    const urlRegex = /(https?:\\/\\/[^\\s]+)/g;\n    const urls = text.match(urlRegex);\n    \n    if (urls && urls.length > 0) {\n      const url = urls[0];\n      \n      // Check if it's YouTube or TikTok\n      if (url.includes('youtube.com') || url.includes('youtu.be')) {\n        routeType = 'youtube';\n        data = {\n          routeType: 'youtube',\n          url: url,\n          chatId: update.message.chat.id,\n          userId: update.message.from.id,\n          username: update.message.from.username || update.message.from.first_name,\n          messageId: update.message.message_id\n        };\n      } else if (url.includes('tiktok.com')) {\n        routeType = 'tiktok';\n        data = {\n          routeType: 'tiktok',\n          url: url,\n          chatId: update.message.chat.id,\n          userId: update.message.from.id,\n          username: update.message.from.username || update.message.from.first_name,\n          messageId: update.message.message_id\n        };\n      } else {\n        // Generic URL - could be RSS or article\n        routeType = 'url';\n        data = {\n          routeType: 'url',\n          url: url,\n          chatId: update.message.chat.id,\n          userId: update.message.from.id,\n          username: update.message.from.username || update.message.from.first_name,\n          messageId: update.message.message_id\n        };\n      }\n    } else {\n      // Regular chat message\n      routeType = 'chat';\n      data = {\n        routeType: 'chat',\n        message: text,\n        query: text,\n        text: text,\n        chatId: update.message.chat.id,\n        userId: update.message.from.id,\n        username: update.message.from.username || update.message.from.first_name,\n        messageId: update.message.message_id,\n        timestamp: new Date().toISOString()\n      };\n    }\n  }\n}\n\nreturn {\n  json: data\n};"
      },
      "id": "1539ce4a-2947-4ebc-a112-a7b754268570",
      "name": "Detect Route Type",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1920,
        800
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.routeType }}",
                    "rightValue": "document",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "89f18cc7-9bef-487d-a1ca-c5a342b04194"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "document"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.routeType }}",
                    "rightValue": "youtube",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "841bc31d-1a89-438c-9998-642a3dfb52ac"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "youtube"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.routeType }}",
                    "rightValue": "tiktok",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "12ed55c4-2ca1-49cc-8ee7-391a5cf92644"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "tiktok"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.routeType }}",
                    "rightValue": "chat",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "fb07703b-28f8-43cc-8831-a18f0dc8b315"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "chat"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.routeType }}",
                    "rightValue": "export",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "export-route-id"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "export"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.routeType }}",
                    "rightValue": "url",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "url-route-id"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "url"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "477527bf-d17c-4ee4-9d84-d03d5a16c6e0",
                    "leftValue": "={{ $json.routeType }}",
                    "rightValue": "skip",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "skip"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.routeType }}",
                    "rightValue": "stats",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "stats-route-id"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "stats"
            }
          ]
        },
        "options": {
          "fallbackOutput": "none"
        }
      },
      "id": "6d03d173-b09c-4b87-a850-04ef0cedc437",
      "name": "Route by Type",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [
        -1700,
        700
      ]
    },
    {
      "parameters": {
        "jsCode": "// Handle external document or download Telegram file\nconst data = $json;\n\nif (data.source === 'external') {\n  // External document - already has URL or content\n  return {\n    json: {\n      ...data,\n      binary: data.fileContent ? {\n        data: {\n          data: data.fileContent,\n          mimeType: data.mimeType,\n          fileName: data.fileName\n        }\n      } : null\n    }\n  };\n} else {\n  // Telegram document - needs download\n  return {\n    json: data\n  };\n}"
      },
      "id": "efbc223c-ec87-4b7c-a2b7-794473a0cc60",
      "name": "Document Source Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1260,
        -60
      ]
    },
    {
      "parameters": {
        "resource": "file",
        "fileId": "={{ $json.fileId }}"
      },
      "id": "da000748-79b1-4f8b-8749-0ea50353f3bf",
      "name": "Download Telegram File",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [
        -800,
        200
      ],
      "webhookId": "f04efaee-7bde-4b16-b94c-90431f7032fb",
      "credentials": {
        "telegramApi": {
          "id": "AxkZ01LKYRFoDdI5",
          "name": "research bot"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('Document Source Handler').item.json.mimeType }}",
                    "rightValue": "application/pdf",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "pdf"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('Document Source Handler').item.json.mimeType }}",
                    "rightValue": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "docx"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('Document Source Handler').item.json.mimeType }}",
                    "rightValue": "text/csv",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "csv"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "1d6dba22-4378-456c-921a-1508f7a26116",
      "name": "Route Document Type",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [
        -580,
        -80
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare message for AI processing\nconst input = $json;\nconst userMessage = input.message || input.query || input.text || '';\n\nif (!userMessage) {\n  throw new Error('No message provided');\n}\n\nreturn {\n  json: {\n    userMessage: userMessage,\n    chatId: input.chatId,\n    userId: input.userId,\n    username: input.username,\n    messageId: input.messageId,\n    timestamp: input.timestamp || new Date().toISOString()\n  }\n};"
      },
      "id": "bdaf302c-3005-4f2a-9a20-928f20778cb1",
      "name": "Prepare Chat Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1480,
        1060
      ]
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "chat_memory",
        "limit": 15,
        "filterType": "string",
        "filterString": "=user_id.eq.{{ $json.userId }},chat_id.eq.{{ $json.chatId }}"
      },
      "id": "4cfb38cc-6661-473a-851d-767e711e7c7b",
      "name": "Get Chat History",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -1240,
        1060
      ],
      "credentials": {
        "supabaseApi": {
          "id": "GTa5PjtKpwbDbZff",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Direct Supabase query for vector search\nconst userMessage = $('Prepare Chat Input').item.json.userMessage;\nconst userId = $('Prepare Chat Input').item.json.userId;\n\n// Simple similarity search query - no RPC function needed\nreturn {\n  json: {\n    query_text: userMessage,\n    user_id: userId,\n    limit: 10\n  }\n};"
      },
      "id": "632d2bc7-f39e-458a-9c20-7aac8c0d0a06",
      "name": "Prepare Vector Search",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1240,
        1260
      ]
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "documents",
        "limit": 10,
        "filterType": "string",
        "filterString": "=user_id.eq.{{ $('Prepare Chat Input').item.json.userId }}"
      },
      "id": "3793a74e-20d6-4d3b-bb1b-5e33160b1d35",
      "name": "Vector Search Documents",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -1020,
        1260
      ],
      "credentials": {
        "supabaseApi": {
          "id": "GTa5PjtKpwbDbZff",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "multiplex",
        "options": {}
      },
      "id": "2fcf4699-33cb-45a6-9b7c-7f414b493736",
      "name": "Merge Chat Data",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [
        -1020,
        1100
      ]
    },
    {
      "parameters": {
        "jsCode": "// Build context from chat history and vector search results\nlet chatData, history = [], searchResults = [];\n\n// Safely get chat data\ntry {\n  chatData = $('Prepare Chat Input').item.json;\n} catch (e) {\n  throw new Error('Chat input data not available');\n}\n\n// Safely get chat history\ntry {\n  history = $('Get Chat History').all() || [];\n} catch (e) {\n  console.log('No chat history available');\n}\n\n// Safely get search results - now from Supabase documents table\ntry {\n  const searchNode = $('Vector Search Documents');\n  if (searchNode && searchNode.all) {\n    searchResults = searchNode.all().map(item => item.json) || [];\n  }\n} catch (e) {\n  console.log('No search results available');\n}\n\n// Format chat history\nconst formattedHistory = history\n  .reverse()\n  .map(msg => `${msg.json.role === 'user' ? 'User' : 'Assistant'}: ${msg.json.content}`)\n  .join('\\n\\n');\n\n// Format search results from documents table\nlet relevantDocs = 'No relevant documents found.';\nif (searchResults.length > 0) {\n  relevantDocs = searchResults.slice(0, 5)\n    .map(doc => {\n      const title = doc.title || 'Untitled';\n      const category = doc.category || 'General';\n      const content = (doc.content || '').substring(0, 500);\n      const filename = doc.filename || 'Unknown file';\n      const classification = doc.classification || 'Unknown';\n      return `Document: ${title}\\nFile: ${filename}\\nCategory: ${category}\\nClassification: ${classification}\\nContent: ${content}...\\n`;\n    })\n    .join('\\n---\\n');\n}\n\n// Build the system message\nconst systemMessage = `You are a helpful AI assistant for Project Horizon. You help users find and understand information about AI's impact on cybersecurity tasks.\n\nRelevant documents from the knowledge base:\n${relevantDocs}\n\nRecent conversation history:\n${formattedHistory || 'No previous messages.'}\n\nIMPORTANT: When asked about what document was just sent or recently uploaded, refer to the most recent document in the relevant documents section above.`;\n\nreturn {\n  json: {\n    systemMessage: systemMessage,\n    userMessage: chatData.userMessage,\n    chatId: chatData.chatId,\n    userId: chatData.userId,\n    username: chatData.username,\n    messageId: chatData.messageId,\n    documentsFound: searchResults.length,\n    historyCount: history.length\n  }\n};"
      },
      "id": "0542518b-9107-4e84-be0c-6405bd88e078",
      "name": "Build AI Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -800,
        1160
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer 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"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"model\": \"gpt-4o-mini\",\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": $json.systemMessage\n    },\n    {\n      \"role\": \"user\",\n      \"content\": $json.userMessage\n    }\n  ],\n  \"temperature\": 0.7,\n  \"max_tokens\": 1000\n} }}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "08f46a90-82e6-42e2-8fa6-b13174983e19",
      "name": "Call OpenAI Chat",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -580,
        1160
      ]
    },
    {
      "parameters": {
        "jsCode": "// Process AI response\nconst aiResponse = $json;\nconst contextData = $('Build AI Context').item.json;\n\n// Extract the AI's message\nconst aiMessage = aiResponse.choices?.[0]?.message?.content || 'Sorry, I could not generate a response.';\n\nreturn {\n  json: {\n    output: aiMessage,\n    userData: {\n      chatId: contextData.chatId,\n      userId: contextData.userId,\n      username: contextData.username,\n      messageId: contextData.messageId\n    },\n    input: contextData.userMessage,\n    documentsUsed: contextData.documentsFound,\n    model: aiResponse.model || 'gpt-4o-mini',\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "id": "81bf736a-6ad7-4e52-b748-2970e803b856",
      "name": "Process AI Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -360,
        1160
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.userData.chatId }}",
        "text": "={{ $json.output }}",
        "additionalFields": {
          "parse_mode": "Markdown",
          "reply_to_message_id": "={{ $json.userData.messageId }}"
        }
      },
      "id": "4d661deb-1761-4fe6-b103-e9599439e57e",
      "name": "Send Telegram Response",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [
        -140,
        1160
      ],
      "webhookId": "f4fb39ad-e6f6-445f-8a68-4716c43807b9",
      "credentials": {
        "telegramApi": {
          "id": "AxkZ01LKYRFoDdI5",
          "name": "research bot"
        }
      }
    },
    {
      "parameters": {
        "tableId": "chat_memory",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.userData.userId }}"
            },
            {
              "fieldId": "chat_id",
              "fieldValue": "={{ $json.userData.chatId }}"
            },
            {
              "fieldId": "username",
              "fieldValue": "={{ $json.userData.username }}"
            },
            {
              "fieldId": "role",
              "fieldValue": "user"
            },
            {
              "fieldId": "content",
              "fieldValue": "={{ $json.input }}"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ JSON.stringify({ messageId: $json.userData.messageId, timestamp: new Date().toISOString() }) }}"
            }
          ]
        }
      },
      "id": "57018d68-52fe-4baa-9d8e-c3f658c690c2",
      "name": "Store User Message",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -140,
        960
      ],
      "credentials": {
        "supabaseApi": {
          "id": "GTa5PjtKpwbDbZff",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "tableId": "chat_memory",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.userData.userId }}"
            },
            {
              "fieldId": "chat_id",
              "fieldValue": "={{ $json.userData.chatId }}"
            },
            {
              "fieldId": "username",
              "fieldValue": "={{ $json.userData.username }}"
            },
            {
              "fieldId": "role",
              "fieldValue": "assistant"
            },
            {
              "fieldId": "content",
              "fieldValue": "={{ $json.output }}"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ JSON.stringify({ \n  model: $json.model, \n  documentsUsed: $json.documentsUsed,\n  timestamp: new Date().toISOString(),\n  hasError: false\n}) }}"
            }
          ]
        }
      },
      "id": "7d662979-3b61-4adc-b69e-49d44eb758cc",
      "name": "Store AI Response",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -140,
        1360
      ],
      "credentials": {
        "supabaseApi": {
          "id": "GTa5PjtKpwbDbZff",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://app.dumplingai.com/api/v1/extract-document",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer sk_wHUE8kEVOvO8InedX5K9MjHxlB6Ws02mPSBBQvPnaH5Nss8q"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"inputMethod\": \"base64\",\n  \"files\": [($('Document Source Handler').item.binary?.data?.data || $('Download Telegram File').item.binary?.data?.data)],\n  \"prompt\": \"Extract all text content from this PDF document. Return the complete text preserving the structure and formatting.\",\n  \"jsonMode\": false\n} }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "b9e0e6c7-f18a-468e-8a8b-190e632fff7a",
      "name": "Extract PDF (Dumpling)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -140,
        -360
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://app.dumplingai.com/api/v1/extract-document",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer sk_wHUE8kEVOvO8InedX5K9MjHxlB6Ws02mPSBBQvPnaH5Nss8q"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"inputMethod\": \"base64\",\n  \"files\": [($('Document Source Handler').item.binary?.data?.data || $('Download Telegram File').item.binary?.data?.data)],\n  \"prompt\": \"Extract all text content from this DOCX document. Return the complete text preserving the structure and formatting.\",\n  \"jsonMode\": false\n} }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "ceaf465b-3a31-4042-af70-c5800e4aca69",
      "name": "Extract DOCX (Dumpling)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -140,
        -160
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "options": {
          "headerRow": true,
          "includeEmptyCells": false
        }
      },
      "id": "c2e9e160-4e8c-4b10-8701-7ed85672b732",
      "name": "Extract CSV",
      "type": "n8n-nodes-base.spreadsheetFile",
      "typeVersion": 2,
      "position": [
        -360,
        60
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://app.dumplingai.com/api/v1/extract-video",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer sk_wHUE8kEVOvO8InedX5K9MjHxlB6Ws02mPSBBQvPnaH5Nss8q"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"inputMethod\": \"url\",\n  \"video\": $json.url,\n  \"prompt\": \"Extract the complete transcript from this YouTube video. Include all spoken words and maintain the natural flow of speech.\",\n  \"jsonMode\": false\n} }}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "4d33fc9c-eaa3-479b-855a-d656ee6bba72",
      "name": "Get YouTube Transcript",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -140,
        400
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://app.dumplingai.com/api/v1/extract-video",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer sk_wHUE8kEVOvO8InedX5K9MjHxlB6Ws02mPSBBQvPnaH5Nss8q"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"inputMethod\": \"url\",\n  \"video\": $json.url,\n  \"prompt\": \"Extract the complete transcript from this TikTok video. Include all spoken words and maintain the natural flow of speech.\",\n  \"jsonMode\": false\n} }}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "a025198a-a94e-4184-b294-dc15e2da795e",
      "name": "Get TikTok Transcript",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -140,
        600
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Process CSV data\nconst csvData = $json;\nconst allRows = [];\n\nObject.keys(csvData).forEach(sheetName => {\n  const sheet = csvData[sheetName];\n  if (Array.isArray(sheet)) {\n    sheet.forEach((row, index) => {\n      allRows.push({\n        ...row,\n        _sheet: sheetName,\n        _rowIndex: index\n      });\n    });\n  }\n});\n\nconst headers = allRows.length > 0 ? Object.keys(allRows[0]).filter(k => !k.startsWith('_')) : [];\nlet textContent = `CSV Data with ${allRows.length} rows and ${headers.length} columns\\n\\n`;\ntextContent += `Headers: ${headers.join(', ')}\\n\\n`;\n\nif (allRows.length > 100) {\n  textContent += `Data Summary:\\n`;\n  textContent += `- Total rows: ${allRows.length}\\n`;\n  textContent += `- Sample data (first 10 rows):\\n`;\n  textContent += JSON.stringify(allRows.slice(0, 10), null, 2);\n} else {\n  textContent += `Full Data:\\n`;\n  textContent += JSON.stringify(allRows, null, 2);\n}\n\nconst metadata = $('Document Source Handler').item.json;\n\nreturn {\n  json: {\n    text: textContent,\n    content: textContent,\n    source_type: 'csv',\n    filename: metadata.fileName,\n    chatId: metadata.chatId,\n    userId: metadata.userId,\n    username: metadata.username,\n    metadata: {\n      rowCount: allRows.length,\n      columnCount: headers.length,\n      headers: headers\n    }\n  }\n};"
      },
      "id": "957a126b-bf06-45a7-a45f-1ee6a36af310",
      "name": "Process CSV",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -140,
        60
      ]
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Normalize Content Node with comprehensive metadata extraction\ntry {\n  console.log(\"Starting content normalization...\");\n  \n  const sources = [\n    { node: 'Extract PDF (Dumpling)', type: 'pdf' },\n    { node: 'Extract DOCX (Dumpling)', type: 'docx' },\n    { node: 'Process CSV', type: 'csv' },\n    { node: 'Get YouTube Transcript', type: 'youtube' },\n    { node: 'Get TikTok Transcript', type: 'tiktok' },\n    { node: 'Extract Web Content', type: 'article' },\n    { node: 'Process RSS Items', type: 'rss' }\n  ];\n  \n  let content = '';\n  let sourceType = '';\n  let metadata = {};\n  let errorMessages = [];\n  \n  // Get route data safely\n  let routeData = {\n    chatId: null,\n    userId: null,\n    username: null,\n    fileName: null,\n    url: null\n  };\n  \n  try {\n    const routeNode = $('Detect Route Type');\n    if (routeNode && routeNode.item && routeNode.item.json) {\n      routeData = routeNode.item.json;\n    }\n  } catch (e) {\n    console.log(\"Route data not available - using defaults\");\n  }\n  \n  // Also check Document Source Handler for metadata\n  try {\n    const docHandler = $('Document Source Handler');\n    if (docHandler && docHandler.item && docHandler.item.json) {\n      const handlerData = docHandler.item.json;\n      routeData = {\n        ...routeData,\n        ...handlerData\n      };\n    }\n  } catch (e) {\n    console.log(\"Document Source Handler data not available\");\n  }\n  \n  for (const source of sources) {\n    try {\n      let nodeData = null;\n      \n      try {\n        const node = $(source.node);\n        if (node && node.item) {\n          nodeData = node.item;\n        }\n      } catch (e) {\n        console.log(`Node ${source.node} not found or has no data`);\n        continue;\n      }\n      \n      if (!nodeData || !nodeData.json) {\n        console.log(`No data from ${source.node}`);\n        continue;\n      }\n      \n      const data = nodeData.json;\n      console.log(`${source.type} response:`, JSON.stringify(data).substring(0, 500));\n      \n      // Check for HTTP error responses\n      if (data.error || (data.statusCode && data.statusCode >= 400)) {\n        errorMessages.push(`${source.type}: ${data.error?.message || data.message || 'Request failed'}`);\n        console.error(`Error from ${source.type}:`, data.error || data.message);\n        continue;\n      }\n      \n      // Handle Dumpling API response format\n      if (data.results) {\n        content = data.results;\n        sourceType = source.type;\n        console.log(`Found Dumpling content from ${source.type}: ${content.length} characters`);\n        \n        // Ensure DOCX is properly detected\n        if (source.node === 'Extract DOCX (Dumpling)') {\n          sourceType = 'docx';\n          console.log('Confirmed source type as DOCX');\n        }\n      }\n      // Handle Process CSV output\n      else if (source.type === 'csv' && (data.text || data.content)) {\n        content = data.text || data.content;\n        sourceType = 'csv';\n        console.log(`Found CSV content: ${content.length} characters`);\n      }\n      // Check for other standard formats\n      else {\n        const textFields = ['text', 'content', 'transcript', 'extracted_text', 'body', 'output', 'result', 'data'];\n        for (const field of textFields) {\n          if (data[field] && typeof data[field] === 'string') {\n            content = data[field];\n            sourceType = source.type;\n            console.log(`Found content in '${field}' field`);\n            break;\n          }\n        }\n      }\n      \n      if (content) {\n        // Build metadata with safe access\n        metadata = {\n          filename: routeData.fileName || data.filename || 'unknown',\n          source_url: routeData.url || data.url || null,\n          chatId: routeData.chatId || null,\n          userId: routeData.userId || null,\n          username: routeData.username || null,\n          extracted_at: new Date().toISOString(),\n          pages: data.pages || null,\n          videoDuration: data.videoDuration || null,\n          creditUsage: data.creditUsage || null,\n          ...(data.metadata || {})\n        };\n        break;\n      }\n    } catch (e) {\n      console.log(`Error processing ${source.type}:`, e.message);\n      errorMessages.push(`${source.type}: ${e.message}`);\n    }\n  }\n  \n  // If no content found, provide detailed error\n  if (!content) {\n    const errorDetail = errorMessages.length > 0 \n      ? `Errors encountered:\\n${errorMessages.join('\\n')}`\n      : 'No content could be extracted from any source.';\n      \n    throw new Error(`Content extraction failed. ${errorDetail}\\n\\nPlease check:\\n1. API keys are valid\\n2. File/URL is accessible\\n3. File size limits (30MB for docs, 2GB for videos)\\n4. API credits are available`);\n  }\n  \n  // Ensure content is string\n  if (typeof content !== 'string') {\n    content = JSON.stringify(content);\n  }\n  \n  // Double-check source type based on file extension\n  if (sourceType === 'error' || !sourceType) {\n    if (routeData.fileName) {\n      const fileName = routeData.fileName.toLowerCase();\n      if (fileName.endsWith('.docx')) {\n        sourceType = 'docx';\n      } else if (fileName.endsWith('.pdf')) {\n        sourceType = 'pdf';\n      } else if (fileName.endsWith('.csv')) {\n        sourceType = 'csv';\n      }\n      console.log(`Set source type from filename: ${sourceType}`);\n    }\n  }\n  \n  return {\n    json: {\n      content,\n      source_type: sourceType,\n      filename: metadata.filename,\n      source_url: metadata.source_url,\n      metadata,\n      content_length: content.length,\n      processing_timestamp: new Date().toISOString()\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      content: '',\n      source_type: 'error',\n      error: true,\n      error_message: error.message,\n      processing_timestamp: new Date().toISOString(),\n      metadata: {\n        chatId: null,\n        userId: null,\n        username: null\n      }\n    }\n  };\n}"
      },
      "id": "a99c5fcb-9991-4ab8-9a5e-0e0c9186cce2",
      "name": "Normalize Content",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        80,
        360
      ]
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Semantic Chunking with Overlap\nfunction semanticChunk(text, maxChunkSize = 1500, overlap = 200) {\n  const sentences = text.match(/[^.!?]+[.!?]+/g) || [];\n  const chunks = [];\n  let currentChunk = '';\n  \n  for (const sentence of sentences) {\n    if ((currentChunk + sentence).length > maxChunkSize) {\n      chunks.push(currentChunk.trim());\n      // Include overlap from previous chunk\n      const overlapText = currentChunk.split(' ').slice(-20).join(' ');\n      currentChunk = overlapText + ' ' + sentence;\n    } else {\n      currentChunk += ' ' + sentence;\n    }\n  }\n  \n  if (currentChunk) chunks.push(currentChunk.trim());\n  \n  return chunks.map((chunk, index) => ({\n    content: chunk,\n    chunk_index: index,\n    total_chunks: chunks.length,\n    metadata: {\n      chunking_strategy: 'semantic_with_overlap',\n      chunk_size: chunk.length\n    }\n  }));\n}\n\n// Get the input data\nconst data = $json;\nconsole.log(\"Input data keys:\", Object.keys(data));\nconsole.log(\"Source type received:\", data.source_type);\nconsole.log(\"Content length received:\", data.content?.length || 0);\n\n// Extract the content\nconst content = data.content || '';\n\nconsole.log(`Starting chunking: ${content.length} characters`);\n\n// If content is empty, return error\nif (!content || content.length === 0) {\n  console.error(\"ERROR: No content to chunk!\");\n  return [{\n    json: {\n      text: '',\n      chunk_index: 0,\n      total_chunks: 1,\n      chunk_size: 0,\n      error: 'No content to chunk',\n      ...data\n    }\n  }];\n}\n\n// Use semantic chunking\nconst semanticChunks = semanticChunk(content);\n\nconst chunks = semanticChunks.map(chunk => ({\n  json: {\n    text: chunk.content,\n    content: chunk.content,\n    chunk_index: chunk.chunk_index,\n    total_chunks: chunk.total_chunks,\n    chunk_size: chunk.metadata.chunk_size,\n    source_type: data.source_type,\n    filename: data.filename,\n    source_url: data.source_url,\n    metadata: { ...data.metadata, ...chunk.metadata },\n    original_length: content.length\n  }\n}));\n\nconsole.log(`Created ${chunks.length} semantic chunks`);\nconsole.log(\"First chunk preview:\", chunks[0]?.json?.text?.substring(0, 100));\n\nreturn chunks;"
      },
      "id": "fbb477ab-f0ab-4ee5-95c9-9311d86f01b3",
      "name": "Chunk Text",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        300,
        360
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer 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"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"model\": \"gpt-4o-mini\",\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"You are an AI classifier for Project Horizon. Analyze text and classify its impact on cybersecurity tasks:\\n- Replace: AI will fully automate this task\\n- Augment: AI will assist but not replace human involvement\\n- Remain Human: Task will remain primarily human-driven\\n- New Task: This represents a new task created by AI advancement\\n\\nAlso identify relevant DCWF task IDs and work roles if mentioned.\\n\\nRespond with JSON only: {\\\"classification\\\": \\\"category\\\", \\\"confidence\\\": 0.0-1.0, \\\"rationale\\\": \\\"explanation\\\", \\\"scores\\\": {\\\"impact\\\": 0.0-1.0, \\\"specificity\\\": 0.0-1.0, \\\"credibility\\\": 0.0-1.0}, \\\"dcwf_tasks\\\": [], \\\"work_roles\\\": []}\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": `Analyze this text for cybersecurity AI impact:\\n\\n${$json.text}\\n\\nSource: ${$json.source_url || $json.filename}`\n    }\n  ],\n  \"temperature\": 0.3,\n  \"max_tokens\": 500,\n  \"response_format\": { \"type\": \"json_object\" }\n} }}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "ffe485c7-f123-4954-81a9-37a991f76136",
      "name": "AI Classification",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        520,
        360
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Enrich Metadata with Complete Field Mapping\nconst chunk = $json;\nconst timestamp = new Date().toISOString();\nconst artifactId = `artifact_${Date.now()}_${chunk.chunk_index || 0}_${Math.random().toString(36).substr(2, 9)}`;\n\n// Get AI classification\nlet aiResponse = '{}';\ntry {\n  const aiNode = $('AI Classification');\n  if (aiNode && aiNode.item && aiNode.item.json) {\n    aiResponse = aiNode.item.json.choices?.[0]?.message?.content || '{}';\n  }\n} catch (e) {\n  console.log(\"AI Classification not available\");\n}\n\nlet classification = {};\ntry {\n  classification = JSON.parse(aiResponse);\n  const validClassifications = ['Replace', 'Augment', 'Remain Human', 'New Task'];\n  if (!validClassifications.includes(classification.classification)) {\n    classification.classification = 'Unknown';\n  }\n} catch (error) {\n  classification = {\n    classification: 'Unknown',\n    confidence: 0,\n    rationale: 'Classification failed',\n    scores: { impact: 0, specificity: 0, credibility: 0 },\n    dcwf_tasks: [],\n    work_roles: []\n  };\n}\n\n// Get metadata and content\nconst metadata = chunk.metadata || {};\nconst contentText = chunk.text || chunk.content || '';\n\n// Generate title from filename or content\nlet title = '';\nif (metadata.filename && metadata.filename !== 'unknown') {\n  title = metadata.filename\n    .replace(/\\.(pdf|docx|txt|csv)$/i, '')\n    .replace(/_/g, ' ')\n    .replace(/\\b\\w/g, l => l.toUpperCase());\n} else if (contentText) {\n  const firstLine = contentText.split('\\n').find(line => line.trim().length > 10);\n  title = firstLine ? firstLine.substring(0, 100) : 'Untitled Document';\n}\n\n// Auto-categorization based on content\nlet category = 'General';\nconst contentLower = contentText.toLowerCase();\n\nif (contentLower.includes('threat') || contentLower.includes('attack') || contentLower.includes('vulnerability')) {\n  category = 'Threat Intelligence';\n} else if (contentLower.includes('incident') || contentLower.includes('response') || contentLower.includes('forensic')) {\n  category = 'Incident Response';\n} else if (contentLower.includes('compliance') || contentLower.includes('policy') || contentLower.includes('governance')) {\n  category = 'Governance & Compliance';\n} else if (contentLower.includes('security operations') || contentLower.includes('soc') || contentLower.includes('monitoring')) {\n  category = 'Security Operations';\n} else if (contentLower.includes('identity') || contentLower.includes('access') || contentLower.includes('authentication')) {\n  category = 'Identity & Access';\n}\n\n// Generate auto-tags\nconst tags = [];\nconst keywords = ['ai', 'machine learning', 'automation', 'threat', 'vulnerability', 'incident', 'compliance', 'cloud', 'zero trust', 'ransomware', 'phishing', 'malware', 'encryption', 'firewall', 'siem', 'soar'];\nkeywords.forEach(keyword => {\n  if (contentLower.includes(keyword)) {\n    tags.push(keyword);\n  }\n});\n\n// Generate summary (comprehensive)\nlet summary = '';\nif (classification.classification && classification.classification !== 'Unknown') {\n  summary += `Classification: ${classification.classification} (${(classification.confidence * 100).toFixed(0)}% confidence). `;\n  summary += `${classification.rationale || 'Analysis pending'}. `;\n}\n\n// Add content preview to summary\nif (contentText.length > 50) {\n  const preview = contentText\n    .replace(/\\s+/g, ' ')\n    .trim()\n    .substring(0, 200);\n  summary += `Content preview: \"${preview}...\"`;\n} else {\n  summary += contentText;\n}\n\n// Ensure all required fields are properly mapped\nreturn {\n  json: {\n    // Core identification\n    artifact_id: artifactId,\n    \n    // Content fields\n    title: title || 'Untitled Document',\n    summary: summary || 'No summary available',\n    content: contentText,\n    \n    // Source information\n    source_url: chunk.source_url || metadata.source_url || null,\n    source_type: chunk.source_type || 'unknown',\n    filename: chunk.filename || metadata.filename || 'unknown',\n    \n    // Chunk information\n    chunk_index: chunk.chunk_index || 0,\n    total_chunks: chunk.total_chunks || 1,\n    chunk_size: chunk.chunk_size || contentText.length,\n    \n    // Timestamps\n    retrieved_on: timestamp,\n    created_at: timestamp,\n    \n    // User information\n    user_id: metadata.userId || metadata.user_id || null,\n    chat_id: metadata.chatId || metadata.chat_id || null,\n    username: metadata.username || null,\n    \n    // AI Classification fields\n    classification: classification.classification || 'Unknown',\n    confidence: parseFloat(classification.confidence) || 0,\n    rationale: classification.rationale || 'No rationale provided',\n    \n    // Scores\n    scores: {\n      credibility: parseFloat(classification.scores?.credibility) || 0,\n      recency: timestamp,\n      impact: parseFloat(classification.scores?.impact) || 0,\n      specificity: parseFloat(classification.scores?.specificity) || 0\n    },\n    impact_score: parseFloat(classification.scores?.impact) || 0,\n    \n    // DCWF fields\n    dcwf_task_ids: Array.isArray(classification.dcwf_tasks) ? classification.dcwf_tasks : [],\n    work_roles: Array.isArray(classification.work_roles) ? classification.work_roles : [],\n    \n    // Categorization\n    category: category,\n    tags: tags.length > 0 ? tags : ['general'],\n    \n    // Complete metadata object\n    metadata: {\n      ...metadata,\n      artifact_id: artifactId,\n      processing_timestamp: timestamp,\n      chunk_metadata: chunk.metadata || {},\n      classification_metadata: classification,\n      auto_categorization: {\n        category: category,\n        tags: tags\n      }\n    }\n  }\n};"
      },
      "id": "ca252ed9-4303-4e39-8c7c-c200b606bd16",
      "name": "Enrich Metadata",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        740,
        360
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer 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"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"model\": \"text-embedding-ada-002\",\n  \"input\": $json.content.substring(0, 8000)\n} }}",
        "options": {
          "timeout": 20000
        }
      },
      "id": "0054a640-80ca-4ddd-95b3-6f7b93118c2f",
      "name": "Generate Embedding",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        960,
        360
      ]
    },
    {
      "parameters": {
        "tableId": "documents",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "artifact_id",
              "fieldValue": "={{ $('Enrich Metadata').item.json.artifact_id }}"
            },
            {
              "fieldId": "title",
              "fieldValue": "={{ $('Enrich Metadata').item.json.title }}"
            },
            {
              "fieldId": "summary",
              "fieldValue": "={{ $('Enrich Metadata').item.json.summary }}"
            },
            {
              "fieldId": "content",
              "fieldValue": "={{ $('Enrich Metadata').item.json.content }}"
            },
            {
              "fieldId": "source_url",
              "fieldValue": "={{ $('Enrich Metadata').item.json.source_url }}"
            },
            {
              "fieldId": "source_type",
              "fieldValue": "={{ $('Enrich Metadata').item.json.source_type }}"
            },
            {
              "fieldId": "filename",
              "fieldValue": "={{ $('Enrich Metadata').item.json.filename }}"
            },
            {
              "fieldId": "classification",
              "fieldValue": "={{ $('Enrich Metadata').item.json.classification }}"
            },
            {
              "fieldId": "confidence",
              "fieldValue": "={{ $('Enrich Metadata').item.json.confidence }}"
            },
            {
              "fieldId": "rationale",
              "fieldValue": "={{ $('Enrich Metadata').item.json.rationale }}"
            },
            {
              "fieldId": "impact_score",
              "fieldValue": "={{ $('Enrich Metadata').item.json.impact_score }}"
            },
            {
              "fieldId": "dcwf_task_ids",
              "fieldValue": "={{ $('Enrich Metadata').item.json.dcwf_task_ids }}"
            },
            {
              "fieldId": "work_roles",
              "fieldValue": "={{ $('Enrich Metadata').item.json.work_roles }}"
            },
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Enrich Metadata').item.json.user_id }}"
            },
            {
              "fieldId": "chat_id",
              "fieldValue": "={{ $('Enrich Metadata').item.json.chat_id }}"
            },
            {
              "fieldId": "username",
              "fieldValue": "={{ $('Enrich Metadata').item.json.username }}"
            },
            {
              "fieldId": "category",
              "fieldValue": "={{ $('Enrich Metadata').item.json.category }}"
            },
            {
              "fieldId": "tags",
              "fieldValue": "={{ $('Enrich Metadata').item.json.tags }}"
            },
            {
              "fieldId": "embedding",
              "fieldValue": "={{ $json.data[0].embedding }}"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ JSON.stringify($('Enrich Metadata').item.json.metadata) }}"
            }
          ]
        }
      },
      "id": "2dd44aa4-81e2-451f-9023-729b166526c9",
      "name": "Store in Supabase",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1180,
        360
      ],
      "credentials": {
        "supabaseApi": {
          "id": "GTa5PjtKpwbDbZff",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Aggregate Success Message - Sends only once after all chunks are processed\nconst allItems = $items();\n\n// Check if this is the last item\nconst currentIndex = $itemIndex;\nconst totalItems = allItems.length;\n\n// Only process on the last item to avoid duplicates\nif (currentIndex !== totalItems - 1) {\n  return [];\n}\n\n// Extract the necessary information\nlet routeData, normalizeData, enrichedData;\n\ntry {\n  routeData = $('Detect Route Type').item.json;\n} catch (e) {\n  routeData = {};\n}\n\ntry {\n  normalizeData = $('Normalize Content').item.json;\n} catch (e) {\n  normalizeData = {};\n}\n\ntry {\n  enrichedData = $('Enrich Metadata').first().json;\n} catch (e) {\n  enrichedData = {};\n}\n\n// Build success message with aggregated data\nconst successMessage = `📄 Document processed successfully!\n\n📌 **File:** ${routeData.fileName || normalizeData.filename || 'Content'}\n📊 **Type:** ${normalizeData.source_type === 'error' ? 'docx' : normalizeData.source_type || 'unknown'}\n📦 **Chunks:** ${totalItems}\n🏷️ **Classification:** ${enrichedData.classification || 'Unknown'}\n⚡ **Confidence:** ${enrichedData.confidence ? (enrichedData.confidence * 100).toFixed(0) + '%' : 'N/A'}\n🗂️ **Category:** ${enrichedData.category || 'General'}\n🏷️ **Tags:** ${enrichedData.tags ? enrichedData.tags.join(', ') : 'none'}\n👤 **User:** ${routeData.username || enrichedData.username || 'Unknown'}\n\n💬 I'll remember this document for our conversation. Ask me anything about it!`;\n\n// Return single message for sending\nreturn {\n  json: {\n    chatId: routeData.chatId,\n    message: successMessage,\n    documentProcessed: true,\n    totalChunks: totalItems,\n    isSystemMessage: true // Flag to identify system messages\n  }\n};"
      },
      "id": "5714c8d0-cd94-4560-bfdf-84c65f10f29c",
      "name": "Aggregate Success Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        360
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.message }}",
        "additionalFields": {
          "parse_mode": "Markdown"
        }
      },
      "id": "532af3a6-a3c8-4212-a07e-da0fb4d7f56e",
      "name": "Send Success Message",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [
        1620,
        460
      ],
      "webhookId": "c8c1fea2-e735-4319-a72b-91518f318929",
      "credentials": {
        "telegramApi": {
          "id": "AxkZ01LKYRFoDdI5",
          "name": "research bot"
        }
      }
    },
    {
      "parameters": {
        "chatId": "={{ $('Detect Route Type').item.json.chatId }}",
        "text": "=❌ Error processing your request:\\n\\n{{ $json.error?.message || $json.message || 'An unknown error occurred' }}\\n\\nPlease try again or contact support.",
        "additionalFields": {
          "parse_mode": "Markdown"
        }
      },
      "id": "63c64673-6d2b-4c54-b741-5428f4459113",
      "name": "Send Error Message",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [
        -360,
        260
      ],
      "webhookId": "0a0fd9e0-4da1-4fcb-84d6-06aaf8f68e67",
      "credentials": {
        "telegramApi": {
          "id": "AxkZ01LKYRFoDdI5",
          "name": "research bot"
        }
      }
    },
    {
      "parameters": {
        "url": "={{ $('Detect Route Type').item.json.url }}",
        "options": {}
      },
      "id": "13475b15-db0d-4e3a-b05f-56346b36be79",
      "name": "RSS Feed Reader",
      "type": "n8n-nodes-base.rssFeedRead",
      "typeVersion": 1,
      "position": [
        -360,
        800
      ]
    },
    {
      "parameters": {
        "url": "={{ $json.url }}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "ebeb14e8-4158-4c20-9eac-096889a0abd8",
      "name": "Extract Web Content",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -140,
        1000
      ]
    },
    {
      "parameters": {
        "jsCode": "// Process RSS Items\nconst items = $input.all();\nconst processedItems = [];\n\nitems.forEach(item => {\n  const data = item.json;\n  processedItems.push({\n    json: {\n      content: data.content || data.description || data.title,\n      source_type: 'rss',\n      source_url: data.link,\n      filename: data.title,\n      metadata: {\n        pubDate: data.pubDate,\n        categories: data.categories || [],\n        author: data.author || 'Unknown',\n        feed_source: 'RSS Feed',\n        ...$('Detect Route Type').item.json\n      }\n    }\n  });\n});\n\nreturn processedItems;"
      },
      "id": "6af0c0ef-87ab-4266-a7e1-accf55a7d718",
      "name": "Process RSS Items",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -140,
        800
      ]
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "084a81cb-9706-48a9-bb56-8027ab134ada",
      "name": "Webhook Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1840,
        260
      ]
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "a4841270-9c92-4cb8-8265-65231f6159d2",
      "name": "Webhook Response Data",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1620,
        260
      ]
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "documents",
        "limit": 100,
        "filterType": "string",
        "filterString": "=user_id.eq.{{ $json.userId }}{{ $json.filters ? ',' + $json.filters : '' }}"
      },
      "id": "d07ec2da-eaf3-41e3-96f9-cdacb30f75d7",
      "name": "Fetch Documents for Export",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -1020,
        1560
      ],
      "credentials": {
        "supabaseApi": {
          "id": "GTa5PjtKpwbDbZff",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Create CSV Export\nconst documents = $input.all();\n\n// Build CSV headers\nconst headers = [\n  'Title',\n  'Source Type',\n  'Classification',\n  'Confidence',\n  'Category',\n  'Tags',\n  'Impact Score',\n  'Created Date',\n  'Content Preview',\n  'Source URL'\n];\n\n// Build rows\nconst rows = documents.map(doc => {\n  const data = doc.json;\n  return [\n    data.title || 'Untitled',\n    data.source_type || 'unknown',\n    data.classification || 'Unknown',\n    (data.confidence * 100).toFixed(0) + '%',\n    data.category || 'General',\n    (data.tags || []).join('; '),\n    data.impact_score?.toFixed(2) || '0',\n    new Date(data.created_at).toLocaleDateString(),\n    (data.content || '').substring(0, 100).replace(/[\\n\\r,]/g, ' ') + '...',\n    data.source_url || ''\n  ];\n});\n\n// Create CSV content\nconst csvContent = [\n  headers.join(','),\n  ...rows.map(row => row.map(cell => `\"${cell}\"`).join(','))\n].join('\\n');\n\n// Create download link\nconst filename = `project_horizon_export_${Date.now()}.csv`;\nconst blob = Buffer.from(csvContent).toString('base64');\n\nreturn {\n  json: {\n    filename: filename,\n    content: csvContent,\n    documentCount: documents.length,\n    exportDate: new Date().toISOString(),\n    userId: $('Detect Route Type').item.json.userId,\n    chatId: $('Detect Route Type').item.json.chatId\n  },\n  binary: {\n    data: {\n      data: blob,\n      mimeType: 'text/csv',\n      fileName: filename\n    }\n  }\n};"
      },
      "id": "0bffa746-4047-46d4-80e9-18ce3d875749",
      "name": "Create CSV Export",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -800,
        1560
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $('Detect Route Type').item.json.chatId }}",
        "text": "CSV File:",
        "additionalFields": {
          "parse_mode": "Markdown",
          "reply_to_message_id": "={{ $('Detect Route Type').item.json.messageId }}"
        }
      },
      "id": "4d86bfd6-73b3-45ed-9b1e-72a060783dd9",
      "name": "Send CSV Export",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [
        -580,
        1560
      ],
      "webhookId": "2844b4b6-c317-4933-a272-8926d57c498a",
      "credentials": {
        "telegramApi": {
          "id": "AxkZ01LKYRFoDdI5",
          "name": "research bot"
        }
      }
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "documents",
        "limit": 1,
        "filterType": "string",
        "filterString": "=user_id.eq.{{ $json.userId }}"
      },
      "id": "fca3abd2-7f02-4537-9014-04eb55d22f97",
      "name": "Get User Stats",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -1020,
        1760
      ],
      "credentials": {
        "supabaseApi": {
          "id": "GTa5PjtKpwbDbZff",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Process stats and send message\nconst stats = $('Get User Stats').all() || [];\nconst routeData = $('Detect Route Type').item.json;\n\n// In a real implementation, you'd aggregate the stats\n// For now, create a formatted message\nconst statsMessage = `📊 **Your Project Horizon Statistics**\n\n📄 Total Documents: ${stats.length}\n\n**AI Impact Classifications:**\n🤖 Replace: ${stats.filter(s => s.json.classification === 'Replace').length} documents\n🤝 Augment: ${stats.filter(s => s.json.classification === 'Augment').length} documents\n👤 Remain Human: ${stats.filter(s => s.json.classification === 'Remain Human').length} documents\n✨ New Task: ${stats.filter(s => s.json.classification === 'New Task').length} documents\n\n⏰ Last Upload: ${new Date().toLocaleString()}`;\n\nreturn {\n  json: {\n    message: statsMessage,\n    chatId: routeData.chatId,\n    messageId: routeData.messageId\n  }\n};"
      },
      "id": "6ca803aa-7b2b-41fa-b96b-1d0a3d6ab851",
      "name": "Process Stats",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -800,
        1760
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.message }}",
        "additionalFields": {
          "parse_mode": "Markdown",
          "reply_to_message_id": "={{ $json.messageId }}"
        }
      },
      "id": "4b8e95f9-c06d-42f7-b371-8754077c6c27",
      "name": "Send Stats Message",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [
        -580,
        1760
      ],
      "webhookId": "2b959bec-7961-41f1-9aa5-f7d6ef77ade6",
      "credentials": {
        "telegramApi": {
          "id": "AxkZ01LKYRFoDdI5",
          "name": "research bot"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Telegram Trigger": {
      "main": [
        [
          {
            "node": "Detect Route Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "External Document Webhook": {
      "main": [
        [
          {
            "node": "Detect Route Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Detect Route Type": {
      "main": [
        [
          {
            "node": "Route by Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route by Type": {
      "main": [
        [
          {
            "node": "Document Source Handler",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get YouTube Transcript",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get TikTok Transcript",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Chat Input",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Fetch Documents for Export",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "RSS Feed Reader",
            "type": "main",
            "index": 0
          }
        ],
        [],
        [
          {
            "node": "Get User Stats",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Document Source Handler": {
      "main": [
        [
          {
            "node": "Download Telegram File",
            "type": "main",
            "index": 0
          },
          {
            "node": "Route Document Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Telegram File": {
      "main": [
        [
          {
            "node": "Route Document Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Document Type": {
      "main": [
        [
          {
            "node": "Extract PDF (Dumpling)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract DOCX (Dumpling)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract CSV",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Send Error Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Chat Input": {
      "main": [
        [
          {
            "node": "Get Chat History",
            "type": "main",
            "index": 0
          },
          {
            "node": "Prepare Vector Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Chat History": {
      "main": [
        [
          {
            "node": "Merge Chat Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Vector Search": {
      "main": [
        [
          {
            "node": "Vector Search Documents",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Vector Search Documents": {
      "main": [
        [
          {
            "node": "Merge Chat Data",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Chat Data": {
      "main": [
        [
          {
            "node": "Build AI Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build AI Context": {
      "main": [
        [
          {
            "node": "Call OpenAI Chat",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call OpenAI Chat": {
      "main": [
        [
          {
            "node": "Process AI Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process AI Response": {
      "main": [
        [
          {
            "node": "Send Telegram Response",
            "type": "main",
            "index": 0
          },
          {
            "node": "Store User Message",
            "type": "main",
            "index": 0
          },
          {
            "node": "Store AI Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract PDF (Dumpling)": {
      "main": [
        [
          {
            "node": "Normalize Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract DOCX (Dumpling)": {
      "main": [
        [
          {
            "node": "Normalize Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract CSV": {
      "main": [
        [
          {
            "node": "Process CSV",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process CSV": {
      "main": [
        [
          {
            "node": "Normalize Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get YouTube Transcript": {
      "main": [
        [
          {
            "node": "Normalize Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get TikTok Transcript": {
      "main": [
        [
          {
            "node": "Normalize Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RSS Feed Reader": {
      "main": [
        [
          {
            "node": "Process RSS Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process RSS Items": {
      "main": [
        [
          {
            "node": "Normalize Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Web Content": {
      "main": [
        [
          {
            "node": "Normalize Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Content": {
      "main": [
        [
          {
            "node": "Chunk Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunk Text": {
      "main": [
        [
          {
            "node": "AI Classification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Classification": {
      "main": [
        [
          {
            "node": "Enrich Metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enrich Metadata": {
      "main": [
        [
          {
            "node": "Generate Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Embedding": {
      "main": [
        [
          {
            "node": "Store in Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store in Supabase": {
      "main": [
        [
          {
            "node": "Aggregate Success Message",
            "type": "main",
            "index": 0
          },
          {
            "node": "Webhook Response Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Success Message": {
      "main": [
        [
          {
            "node": "Send Success Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook Response Data": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Documents for Export": {
      "main": [
        [
          {
            "node": "Create CSV Export",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create CSV Export": {
      "main": [
        [
          {
            "node": "Send CSV Export",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User Stats": {
      "main": [
        [
          {
            "node": "Process Stats",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Stats": {
      "main": [
        [
          {
            "node": "Send Stats Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "80f9dfa6-08e2-49e9-8789-b9f8270c15be",
  "meta": {
    "instanceId": "e88ec2ec6d01354e27338959397ff3a57e12ad537d768779a0bc52f56ccef5db"
  },
  "id": "79cUPxxcDisBVuBa",
  "tags": []
}